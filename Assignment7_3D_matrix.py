# -*- coding: utf-8 -*-
"""Assignment 7 - 3D Matrix.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_AOwAo-B0m5ApLZKMCmgSz1wdy5ni1nv
"""

import numpy as np

# Step 1: Create an empty 3D matrix
def createEmptyMat():
    empty_matrix = np.zeros((7, 5, 3), dtype=int)  # Create a 3D matrix of size 7x5x3 filled with zeros
    return empty_matrix

# Step 2: Update the matrix with 1s and 0s based on the sum of indices
def update_matrix(matrix):
    # Iterate over each element in the 3D matrix
    for i in range(len(matrix)):          # Loop over the 1st dimension
        for j in range(len(matrix[i])):   # Loop over the 2nd dimension
            for k in range(len(matrix[i][j])):  # Loop over the 3rd dimension
                index_sum = i + j + k
                # Assign 1 if the sum of indices is odd, else assign 0
                if (index_sum % 2 == 0):
                    matrix[i][j][k] = 0  # Even sum, insert 0
                else:
                    matrix[i][j][k] = 1  # Odd sum, insert 1
    return matrix

# Step 3: Finding the longest contiguous substring of 1s
def find_longest_substring(matrix):
    largest, coordinates = 0, []

    # Helper function to check a single line (row, column, depth)
    def check_line(line):
        nonlocal largest, coordinates
        count, temp = 0, []  # Track length of current 1s sequence and coordinates

        for pos in line:
            if pos[0] == 1:  # If the value is 1
                count += 1
                temp.append(pos[1])  # Append the coordinates of 1
            else:
                if count > largest:  # If current count is larger than the largest found
                    largest, coordinates = count, temp[:]
                count, temp = 0, []  # Reset count and temp

        if count > largest:  # Final check after exiting loop
            largest, coordinates = count, temp[:]

    # Check all directions in the 3D matrix
    for d in range(7):  # Loop over depth
        for r in range(5):  # Loop over rows
            check_line([(matrix[d][r][c], [d, r, c]) for c in range(3)])  # Check along columns

        for c in range(3):  # Loop over columns
            check_line([(matrix[d][r][c], [d, r, c]) for r in range(5)])  # Check along rows

    for r in range(5):
        for c in range(3):
            check_line([(matrix[d][r][c], [d, r, c]) for d in range(7)])  # Check along depth

    print(f"Largest contiguous subarray of 1s: {largest}")
    print("Coordinates:", coordinates)

# Step 4: Main function to run the entire process
def main():
    # Step 1: Create an empty matrix
    matrix = createEmptyMat()

    # Step 2: Update the matrix with 1s and 0s
    matrix = update_matrix(matrix)

    # Display updated matrix
    print("Updated Matrix:")
    for layer in matrix:
        for row in layer:
            print(row)
        print()

    # Step 3: Find and display the longest substring of 1s and its coordinates
    find_longest_substring(matrix)

# Run the main function
main()